**Лабораторная работ №1**   
по дисциплине: **Основы DevOps**   
на тему: **"Docker: создание и управления контейнерами"**   
Группа: **ПИ-431Б**   
Студент: **Махмутов Чингиз Ильдарович**   
Принял: **Аитбаев Вадим**   

___
# 1. Цели работы
Целью работы является изучение работы с программным обеспечением Docker для автоматизации развертывания и управления приложениями в средах с поддержкой контейнеризации.

___
# 2. Теоретическая часть
## 2.1. Docker

Docker — программное обеспечение (ПО) для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений. Позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер, который может быть развёрнут на любой Linux-системе с поддержкой контрольных групп в ядре, а также предоставляет набор команд для управления этими контейнерами.

Docker — это открытая платформа для разработки, доставки и запуска приложений. Docker позволяет отделить приложения от инфраструктуры, чтобы в дальнейшем быстро выполнять «доставку» программного обеспечения.
## 2.2. Платформа Docker

Docker предоставляет возможность упаковывать и запускать приложение в изолированной среде, называемой контейнером. Можно запускать множество контейнеров одновременно на одном хосте. Контейнеры достаточно легки и содержат все необходимое для запуска приложения, поэтому не требуется устанавливать на хосте дополнительное ПО. Также контейнеры можно передавать на другие машины и их там запускать, при этом работать будет все одинаково.

Docker предоставляет инструменты и платформу для управления жизненным циклом контейнеров:
- разработка приложений и компонентов с помощью контейнеров;
- контейнер становится единицей распространения и тестирования приложения;
- приложение разворачивается в рабочей среде в виде контейнера.

Использовать Docker можно для:
- быстрой и последовательной доставки приложений;
- адаптивного развертывания и масштабирования;
- запуска большего количества рабочих приложений.
## 2.3. Архитектура Docker

Docker использует клиент-серверную архитектуру. Клиент Docker взаимодействует с демоном Docker, который выполняет работу по созданию, запуску и распространению контейнеров Docker. Клиент Docker и демон могут работать в одной системе, или можно подключить клиент Docker к удаленному демону Docker. Клиент Docker и демон взаимодействуют с помощью REST API, через сокеты UNIX или сетевой интерфейс. Еще один клиент Docker — Docker Compose, который позволяет работать с приложениями, состоящими из набора контейнеров (рисунок 1).   

 ![alt text](https://github.com/ChinaGiza/DevOpsResults/blob/main/DockerArchitecture.png)   
 Рис. 1. Архитектура Docker

Демон Docker (dockerd) прослушивает запросы Docker API и управляет объектами Docker (образы, контейнеры, сети и volume). Клиент Docker (docker) – это способ взаимодействия пользователей с Docker. Когда используются команды, то клиент отправляет эти команды в демон Docker, который их выполняет.

Docker registries хранит образы Docker. В лабораторной работе будет использоваться Docker Hub – это общедоступный registry (реестр), который может использовать любой пользователь.

Образ (image) Docker – это шаблон доступный только для чтения (read only) с инструкциями по созданию контейнера Docker. Образы часто основаны на других образах с некоторыми дополнительными настройками. Можно создавать свои образы или пользоваться существующими образами.

Контейнер (container) Docker – это исполняемый экземпляр образа. Контейнеры можно создавать, запускать, останавливать, перемещать или удалять с помощью Docker API или CLI. Контейнеры можно подключать к сети или нескольким сетям, а также к контейнеру можно подключить некоторое хранилище.
## 2.4. Команды для управления контейнерами

Общий синтаксис: `docker container [название команды]`, где иногда ключевое слово container опускают, так как подразумевается работа с контейнерами по умолчанию.

Названия команд:
- `create` — создает контейнер из выбранного образа;
- `start` — запускает существующий контейнер;
- `run` — создает новый контейнер и сразу его запускает;
- `ls` — отображает все существующие контейнеры;
- `inspect` — подробнее рассказывает о выбранном контейнере;
- `logs` — выводит в консоль логи (журнал событий);
- `stop` — пытается остановить выбранный контейнер, отправив ему сигнал SIGTERM, требующий завершить всю активность и сохранить пользовательские данные. Если ответ занимает слишком много времени, то следом посылает сигнал SIGKILL, чтобы «убить» процесс без сохранения данных;
- `kill` — выполняет ту же задачу, что и предыдущая команда, но пропускает шаг с отправкой SIGTERM. Сразу выключает контейнер, игнорируя сохранение пользовательских данных;
- `rm` — удаляет выбранный контейнер (он должен быть выключен, чтобы команда сработала, либо можно использовать флаг –f для принудительного удаления).
## 2.5. Команды для управления образами

Для управления образами в Docker существуют команды:
- `build` — собирает образ с нуля;
- `push` — отправляет образ в реестр;
- `pull` — загружает готовый образ;
- `ls` — показывает все существующие образы;
- `history` — показывает каждый слой образа;
- `inspect` — предоставляет информацию об образе;
- `rm` — удаляет образ Docker из системы;
- `images` — списком показывает все образы на диске.

Общий синтаксис команд: `docker image [название команды]`
## 2.6. Dockerfile

В файлах Dockerfile содержатся инструкции по созданию образа. Инструкции обрабатываются сверху вниз.

Инструкции Dockerfile:
1. `FROM` — задаёт базовый (родительский) образ.
2. `LABEL` — описывает метаданные (например, кто создал и поддерживает образ).
3. `ENV` — устанавливает постоянные переменные среды.
4. `RUN` — выполняет команду и создаёт слой образа (используется для установки пакетов).
5. `COPY` — копирует файлы и папки в контейнер.
6. `ADD` — копирует файлы и папки, может распаковывать локальные .tar файлы.
7. `CMD` — описывает команду с аргументами для выполнения при запуске контейнера (может быть только одна инструкция CMD).
8. `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
9. `ARG` — задаёт переменные для передачи Docker во время сборки образа.
10. `ENTRYPOINT` — предоставляет команду с аргументами для выполнения контейнера (аргументы не переопределяются).
11. `EXPOSE` — указывает необходимость открыть порт.
12. `VOLUME` — создаёт точку монтирования для постоянного хранения.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY` и `ADD`. Другие инструкции настраивают, описывают метаданные, или сообщают Docker, что во время выполнения контейнера нужно что-то сделать.
## 2.7. Docker-compose

Docker-compose — надстройка над Docker, написанная на Python, которая позволяет запускать множество контейнеров одновременно и маршрутизировать потоки данных между ними.

Docker Compose используется для одновременного управления несколькими контейнерами, входящими в состав приложения.

Для установки: `apt install docker-compose`

Для работы с docker-compose создаётся файл `docker-compose.yml`, содержащий инструкции для запуска и настройки сервисов. Этот файл имеет расширение `.yml`, что означает использование языка сериализации данных, понятного человеку.

___
# 3. Практическая часть

## 3.1. Изучение теоретических материалов и установка Docker

Были изучены теоретические материалы по Docker и docker-compose.

Были установлены необходимые пакеты для работы с Docker. Например:
* Docker Engine
* docker-compose
* Docker Desktop
## 3.2. Создание Dockerfile и запуск контейнера

Был создан Dockerfile, который содержит следующий код:
``` Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt ./

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 1234

CMD ["python", "app.py"]
```

Данный Dockerfile содержит инструкцию по созданию образа, где:
* `FROM python:3.11-slim` - указывает, что данный образ будет создаваться на основе образа `python:3.11-slim`
* `WORKDIR /app` - указывает, что директория `app` является рабочей для следующих инструкций
* `COPY requirements.txt ./` - копирует файл `requirements.txt` в контейнер
* `RUN pip install --no-cache-dir -r requirements.txt` - выполняет команду по установке python-пакетов, указанных в файле `requirements.txt`, без использования кэша.
* `COPY . .` - копирует все папки и файлы в контейнер
* `EXPOSE 1234` - указывает, что данный контейнер будет прослушивать порт 1234
* `CMD ["python", "app.py"]` - описание команды, который будет выполняться при запуске контейнера

На основе данного Dockerfile был собран образ `hello-docker-main`. Для сборки использовалась команда: `docker build -t hello-docker-main .`

На основе данного образа при помощи команды `docker run -d -p 1234:1234 hello-docker-main` был запущен контейнер.

Результат работы:
![alt text](https://github.com/ChinaGiza/DevOpsResults/blob/main/DockerfileResult.png)
## 3.3. Создание docker-compose.yml и запуск контейнера

Был создан docker-compose.yml, который содержит следующий код:
``` yml
version: '3.8'

services:

  web:
    build: .
    container_name: python_app
    ports:
      - 1234:1234
    environment:
      APP_PORT: 1234
      POSTGRES_HOST: db
      POSTGRES_DB: testdb
      POSTGRES_USER: testuser
      POSTGRES_PASSWORD: testpass
    depends_on:
      - db
    restart: always

  db:
      image: postgres:16
      container_name: postgres_db
      environment:
        POSTGRES_DB: testdb
        POSTGRES_USER: testuser
        POSTGRES_PASSWORD: testpass
      volumes:
        - postgres_data:/var/lib/postgresql/data
      restart: always

volumes:
  postgres_data:
```

Данный Dockerfile содержит инструкцию по созданию образа, где:
* `version: '3.8'` - определяет версию схемы файла
* `services:` - раздел с определением сервисов (контейнеров)
* `web:` - определение сервиса `web`
* `db:` - определение сервиса `db`
* `build: .` - указывает, что образ собирается из Dockerfile в текущей директории
* `image: postgres:16` - указывает, что используется готовый образ PostgreSQL версии 16
* `container_name: <name>` - указывает, что имя контейнера соответствует явно указанному имени `<name>`
* `ports:` - раздел для проброса портов между контейнером и хостом
* `environment:` - раздел для переменной среды
* `POSTGRES_HOST: db` - указывает хост базы данных
* `POSTGRES_DB: testdb`
	1. для `web` - устанавливает имя базы данных
	2. для `db` - создает базу данных с указанным именем при первом запуске
* `POSTGRES_USER: testuser`
	1. для `web` - устанавливает пользователя базы данных
	2. для `db` - создает пользователя базы данных с указанным именем
* `POSTGRES_PASSWORD: testpass` - устанавливает пароль пользователя базы данных
* `depends_on` - указывает сервисы, от которых зависит данный сервис
* `volumes:` - раздел для подключения постоянных хранилищ
* restart: always - указывает на перезапуск контейнер при выходе

На основе данного docker-compose.yml были собраны два образа `hello-docker-web` и `postgres`. Для сборки использовалась команда: `docker-compose up -d`. Также при помощи данной команды были запущены контейнеры.

Результат работы:
![alt text](https://github.com/ChinaGiza/DevOpsResults/blob/main/DockerComposeResult.png)

___
# Вывод

В данной лабораторной работе были получены навыки работы с программным обеспечением Docker для автоматизации развертывания и управления приложениями в средах с поддержкой контейнеризации. Были рассмотрены способы cборки контейнера при помощи Dockerfile и управления множества контейнеров при помощи docker-compose.
